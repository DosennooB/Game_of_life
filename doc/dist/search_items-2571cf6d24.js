searchNodes=[{"doc":"Der Einsprungspunkt des Prgramms","ref":"GameOfLife.html","title":"GameOfLife","type":"module"},{"doc":"","ref":"GameOfLife.html#start/2","title":"GameOfLife.start/2","type":"function"},{"doc":"Ist die eingentliche Ansicht des Zellautomaten.Besteht aus einem Spielfeld aus Buttons, die jeweils eine Zelle representieren. Durch den Button &quot;next&quot; kann der nächte Zustand des Spielfeldes berechnet werden. Durch &quot;run&quot; wird der der Zelleautomat angegewiesen in Intervallen seinen Zustand neu zu berechnen.","ref":"GameOfLife.Scene.Field.html","title":"GameOfLife.Scene.Field","type":"module"},{"doc":"Baut das Zellgitter gemäß den Dimensionen auf.Funktion erstellt buttons in passenden Größen und Positionen. Gibt diesen Graph zum Schluss zurrück","ref":"GameOfLife.Scene.Field.html#build_up/5","title":"GameOfLife.Scene.Field.build_up/5","type":"function"},{"doc":"Passt den Zustand der Zellen anÄndert das Aussehen der Zellen so das sie dem neuen Zustand des Automaten enstsprechen.","ref":"GameOfLife.Scene.Field.html#change_theme/3","title":"GameOfLife.Scene.Field.change_theme/3","type":"function"},{"doc":"Verarbeitet die Eingabe eines Buttons.{:click, z::Zelle.t()} Event auf dem Spielfeldraster. Zelle.t() wird dem Zellautomaten übergeben updatet die GUI{:click, :next_step} Lässt den Automaten den neuen Zustand berechnen und die GUI den neuen State annehmen.{:click, :intervall} Gibt den Zellautomaten dass Signal automatisch weiter zu laufen oder aufzuhören. Updatete den Button entsprechend.","ref":"GameOfLife.Scene.Field.html#filter_event/3","title":"GameOfLife.Scene.Field.filter_event/3","type":"function"},{"doc":"Initialisierung der OberflächeLäst das Gitter anhand der Dimensionen aus Agent :xy aufbauen.","ref":"GameOfLife.Scene.Field.html#init/2","title":"GameOfLife.Scene.Field.init/2","type":"function"},{"doc":"Extrahiert Ids aus dem Graph#Mit diesen Ids wird change_theme() aufgerufen.","ref":"GameOfLife.Scene.Field.html#refrech_cell/2","title":"GameOfLife.Scene.Field.refrech_cell/2","type":"function"},{"doc":"Scene wird als erstes aufgerufen. In ihr werden die Dimension des Zellautomaten eingegeben.Wichtig: Zellen nur in Dimensionen bis maximal 20x20 eingeben. In der aktuellen Version eine Limitation des Frameworks","ref":"GameOfLife.Scene.Home.html","title":"GameOfLife.Scene.Home","type":"module"},{"doc":"Reagiert auf Benutzereingaben{:click, :start} Startet und übergibt den Zellautomaten die Dimensionen. Ruft das Hauptfenster auf.{:value_changed, :reihe, value} Neuer Wert für Reihe im State aktualisiert.{:value_changed, :spalte, value} Neuer Wert für Zeile im State akualisiert.","ref":"GameOfLife.Scene.Home.html#filter_event/3","title":"GameOfLife.Scene.Home.filter_event/3","type":"function"},{"doc":"Callback implementation for Scenic.Scene.init/2.","ref":"GameOfLife.Scene.Home.html#init/2","title":"GameOfLife.Scene.Home.init/2","type":"function"},{"doc":"Logic des Zellautomaten. Die nötigen Paarameter werden in Agents gespeichert.Agents:xy: hier werden die Dimensionen des Zellautomaten gespeichert es wird auch noch gespeichert ob der Automat von selber laufen soll oder nichtakt_map: Die Werte der zellen werden als 1 und 0 in einer map mit dem Zellenstruct als id gespeichert um Platz zu sparen werden nach möglichkeit nur zellen mit 1 gespeichertnew_map: dient als Zwischenspicher bei der Berechnung des neuen Zellautomatentodo: enthält Zellen die zum nächsten Schritt neu berechnet werden müssen","ref":"Zellautomat.html","title":"Zellautomat","type":"module"},{"doc":"Enscheidet über den Zustand der ZelleÜberprüft ob die Zelle den Wert 0 oder 1 bekommt, anhand des eigenen Wertes und der Summe der Nachbarn. Übergibt nur Zellen mit Wert 1 dem :new_map Agent","ref":"Zellautomat.html#alive_in_new_map/1","title":"Zellautomat.alive_in_new_map/1","type":"function"},{"doc":"Summe der NachtbarnBerechnet die Summe der Umligenden Zellen und gibt diese zurück.","ref":"Zellautomat.html#around_wert/6","title":"Zellautomat.around_wert/6","type":"function"},{"doc":"HauptschleifeEs werde drei Signale verarbeitet die neuen Werte werden über {:new_map, data :: map()} zurück gegeben.toggel_cell: Es kann geziehlt eine Zelle an oder aus geschaltet werden, abhängig von ihrem aktuellen Zustand.new_tick: Der nächste Zustand des Automaten wird berechnet.automatic_tick: Alle n Sekunden wird ein neuer Zustand der Zellautomaten berechnet. Durch den Parameter toggle kann diese Funktion an oder ausgeschaltet werden.","ref":"Zellautomat.html#automat/0","title":"Zellautomat.automat/0","type":"function"},{"doc":"Initialisierung des Automaten.Starten der Agenten und setzen der Dimensionen für den Zellautomaten.","ref":"Zellautomat.html#init/0","title":"Zellautomat.init/0","type":"function"},{"doc":"Lässt den nächsten Zustand des Zellautomaten berechnen.Lässten nächten Zustand berechnen und gibt die neuen Werte an die Agents weiter. Nur Zellen die den Wert 1 haben oder Nachtbar einer Zelle mit dem Wert 1 sind, werden berechnet.","ref":"Zellautomat.html#tick/0","title":"Zellautomat.tick/0","type":"function"},{"doc":"Ermittelt Nachtbarn und die angegebene Zelle.Übergibt alle Nachtbarn und die angegebene Zelle, dem :todo Agent. Es sei den, sie befinden sich auserhalb des Zellautomaten.","ref":"Zellautomat.html#todo_zellen_around/1","title":"Zellautomat.todo_zellen_around/1","type":"function"},{"doc":"Gibt die Koordinaten im Zellautomaten wiederParameterx, y: Koordinaten im Zellautomaten","ref":"Zelle.html","title":"Zelle","type":"module"},{"doc":"","ref":"Zelle.html#t:t/0","title":"Zelle.t/0","type":"type"},{"doc":"GameOfLifeDies ist eine kleine Implementation von Conways Spiel des Lebens. Das Programm ist in Elixir geschrieben und nutz das Scenic von Boyd Multerer als Grafik Framwork.","ref":"gameoflife.html","title":"GameOfLife","type":"extras"},{"doc":"InstallationBedienungAnforderungen und ÜberlegungenKritik und Änderungen","ref":"gameoflife.html#%C3%BCbersicht","title":"GameOfLife - Übersicht","type":"extras"},{"doc":"InstallationUm dieses Pogramm kompilieren und ausführen zu können, sind ein paar Besonderheiten zu beachten.-Betriebsystem: Auf Grund des Framworks wird entwerder eine Linux oder MacOS Distribution vorraus gesetzt. Alternativ ist es möglich das Pogramm in Windows und WSL zu starten.-Erlang und Elixir: Für das ausfüren de Pogramms ist eine Instalation der Erlang- VM und von Elixir nötig.-Bibliotehken: Scenic setzt GLFW und GLEW Biliotehken vorraus. Installationsanleitungen finden Sie hier.","ref":"installation.html","title":"Installation","type":"extras"},{"doc":"sudo apt-get update sudo apt-get install pkgconf libglfw3 libglfw3-dev libglew2.1 libglew-dev","ref":"installation.html#f%C3%BCr-ubuntu-20","title":"Installation - Für Ubuntu 20","type":"extras"},{"doc":"Zum nutzen von Scenic unter WSL folgen Sie dieser Anleitung.-Vor dem Kompilieren: Nach dem clonen des Git-Repositorys werden mit dem Befehle mix do deps.getdie restlichen Abhängigkeiten herruntergeladen.Mit mix scenic.runwird das Programm gestartet.","ref":"installation.html#f%C3%BCr-wsl-unter-windows-10","title":"Installation - Für WSL unter Windows 10","type":"extras"},{"doc":"BedienungDas Besteht aus zwei verschiedenen Ansichten.","ref":"bedienung.html","title":"Bedienung","type":"extras"},{"doc":"In der ersten Ansicht ist wird die Dimension ausgewählt die nachher der Zellautomat haben soll. Dazu wird in den jeweiligen Textfeldern die entsprechende Zahl eingetragen. Aktuell werden nicht mehr als eine Dimension von 20x20 unterstützt.","ref":"bedienung.html#auswahl","title":"Bedienung - Auswahl","type":"extras"},{"doc":"In der zweiten Ansicht ist jetzt das Feld des Zellautomaten zu sehen. Die einzelnen Felder können durch anklicken ihren Status ändern.Unten links ist der Button next zu sehen. Durch auslösen des Buttons wird der nächte Zustand des Buttons berechnet und angezeigt.Unten Rechts ist der Button run zu sehen. Dieser lässt den Zellautomaten in Intervallen jede Sekunde neu berechen. Durch einen weitern click auf den Button wird der Automat wieder angehalten. wichtig: Beim aktiviren von run wird das Feld in dieser Version nicht automatisch aktualisiert.","ref":"bedienung.html#das-feld","title":"Bedienung - Das Feld","type":"extras"},{"doc":"Anforderungen und Überlegungen","ref":"anforderungen.html","title":"Anforderungen und Überlegungen","type":"extras"},{"doc":"Für mich gab es zu diesem Projekt ein Paar Anforderungen die ich mir im Vorhinein aufgeschrieben hatte.1.) Das Programm soll eine grafische Nutzeroberfläche haben in der der Zellautomat dagestell wird. 2.) Der Zellautomat muss mit Verschiedenen Dimensionen initialisiert werden können.3.) Ein Feld im Zellautomaten kann durch anklicken ihren Zustand wechseln.4.) Der Nutzer soll die Möglichkeit haben durch eine Eingabe den nächsten Zustand berechnen zu lassen.5.) Der Nutzer soll die Möglichkeit haben durch eine Eingabe die nächsten Zustände in einem Intervall berechnen zu lassen.Anforderung 5.) werde ich nicht ohne große Änderungen am Code umsetzte können.","ref":"anforderungen.html#anforderungen","title":"Anforderungen und Überlegungen - Anforderungen","type":"extras"},{"doc":"Die Wahl der Programmiersprache ist in diesem Fall aus persönlichen Gründen gefallen. Ich habe vor kurzem angefangen mit Elixir zu beschäfftigen und habe gedacht das dies eine weitere gute Übung für mich in dieser Sprache sein kann. Allerdings habe ich zuvor nicht mit Oberflächen in dieser Sprache gearbeitet. Die Wahl des Grafik Frameworks fiel auf Scenic. Dies schien mir als die beste Lösung um es in der kurzen Zeit soweit zu verstehen, dass ich das Projekt damit umsetzten könnte. Allerdings bin ich bei der Ausarbeitung auf Limitationen gestoßen.","ref":"anforderungen.html#auswahl-der-programmiersprache","title":"Anforderungen und Überlegungen - Auswahl der Programmiersprache","type":"extras"},{"doc":"Das Programm besteht im weitesten Sinne aus einer Client Server Architektur. Der Client hier die Nutzeroberfläche reagiert auf Nutzereingaben und schick diese als Elixir Massage an den Server weiter der diese Beantwortet.Besonderheiten der NutzeroberflächeDas Feld des Zellautomaten in der Nutzteroberfläche ist mit Buttons realisiert. Jeder dieser Button hat als Id ein Struct vom Typ Zelle. Dieses wird auch im Server zur adressierung genutz. Es ist also keine spezielle zu Ordnung nötig.Besonderheiten des ServersDer Server ist ein seperater Prozess. Enthält nur die Logik. Die Datenspeicherung übernehmen weitere Prozesse. Die sogenanten Agents. Da die Elixir standart Bibliotehk keine Arrays an bietet, habe ich beschlossen die Werte als Key Value Paare zu speichern wobei der Key das Struct vom Typ Zelle ist. Um Speicher zu sparen werden nach möglichkeit nur Zellen mit dem Value 1 (also Lebende) gespeichert. Um Rechenleistung zu sparen werden für den nächsten Zustand nur die Lebenden Zellen und deren Nachtbarn berechnet.","ref":"anforderungen.html#struktur-des-programms","title":"Anforderungen und Überlegungen - Struktur des Programms","type":"extras"},{"doc":"Kritik und Änderungen","ref":"kritikund%C3%A4nderungen.html","title":"Kritik und Änderungen","type":"extras"},{"doc":"Das Prgramm ist in drei großen Punkten limitiertDimension: Durch die Nutzung von Buttons als Feld des Zellautomaten ist das Pogramm in der Dimension beschränkt eine ab einer gewissen Zahl an Button stürzt das Grafik Framework ab.Aktualisierung: Es ist mir kein Weg bekannt gewesen eine Callback Methode in der Nutzeroberfläche zu implementieren. Dadurch kann der Server des Zellautomaten keine Aktualisierung der Nutzeroberfläche anstoßen.Anpassbarkeit Das Programm ist nur auf eine Fenstergröße ausgerichtet. Diese kann nicht verändert werden.","ref":"kritikund%C3%A4nderungen.html#limitationen","title":"Kritik und Änderungen - Limitationen","type":"extras"},{"doc":"Ein Programm zu erstellen mit einem Framwork das man erst wärend des versteht, birgt einige Risiken. Vorallem wenn Limitationen erst nach und nach bekannt werden.","ref":"kritikund%C3%A4nderungen.html#kritik","title":"Kritik und Änderungen - Kritik","type":"extras"},{"doc":"Für eine Zükünftige weitere Entwicklung des Pogramms währen folgende Dinge möglich.Button ersetzen: Um mehr Zellen in der Benutzeroberflächen anzeigen zu können. Müssen die Button durch z.B. Rechtecke (Rect) ersetzt werden. Diese können in höheren Stückzahlen erscheinen.Aktualisierung: Eine Möglichkeit finden die einen Oberflächenaktualisierung in Intervallen ermöglicht.Testerweiterung: Die Tests in der Aktuellen Version decken nur einen kleinen Teil des Pogramms ab. Diese sollten in Zukunft ausgebaut werden.Fensteränderung: Zukünftick sollte man in der ersten Ansicht die Möglichkeit haben die Größe des Fensters ein zustellen oder zu mindest einen Skalierungsfaktor zu nutzen.","ref":"kritikund%C3%A4nderungen.html#%C3%A4nderungen","title":"Kritik und Änderungen - Änderungen","type":"extras"}]