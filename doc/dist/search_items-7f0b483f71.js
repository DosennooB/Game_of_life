searchNodes=[{"doc":"Der Einsprungspunkt des Prgramms","ref":"GameOfLife.html","title":"GameOfLife","type":"module"},{"doc":"","ref":"GameOfLife.html#start/2","title":"GameOfLife.start/2","type":"function"},{"doc":"Ist die eingentliche Ansicht des Zellautomaten.Besteht aus einem Spielfeld aus Buttons, die jeweils eine Zelle representieren. Durch den Button &quot;next&quot; kann der nächte Zustand des Spielfeldes berechnet werden. Durch &quot;run&quot; wird der der Zelleautomat angegewiesen in Intervallen seinen Zustand neu zu berechnen.","ref":"GameOfLife.Scene.Field.html","title":"GameOfLife.Scene.Field","type":"module"},{"doc":"Zeichent horizontale LinienDie Linien erzeugen die passenden Rechtecke die dem State des Zellautomaten passen.","ref":"GameOfLife.Scene.Field.html#build_lines_h/3","title":"GameOfLife.Scene.Field.build_lines_h/3","type":"function"},{"doc":"Zeichent vertikale LinienDie Linien erzeugen die passenden Rechtecke die dem State des Zellautomaten passen.","ref":"GameOfLife.Scene.Field.html#build_lines_v/3","title":"GameOfLife.Scene.Field.build_lines_v/3","type":"function"},{"doc":"Baut das Zellgitter mit den jeweiligen state des Zellautomaten auf.Ruft Funktionen für das erstellen des Gitters und zeichnen der aktiven Zellen auf.","ref":"GameOfLife.Scene.Field.html#build_rect/2","title":"GameOfLife.Scene.Field.build_rect/2","type":"function"},{"doc":"Zeichnet die aktiven Zellen.Die Zellen in der Liste werden schwarz gezeichnet.","ref":"GameOfLife.Scene.Field.html#fill_rect/4","title":"GameOfLife.Scene.Field.fill_rect/4","type":"function"},{"doc":"Verarbeitet die Eingabe eines Buttons.{:click, :next_step} Lässt den Automaten den neuen Zustand berechnen.{:click, :intervall} Gibt den Zellautomaten dass Signal automatisch weiter zu laufen oder aufzuhören. Updatete den Button entsprechend.","ref":"GameOfLife.Scene.Field.html#filter_event/3","title":"GameOfLife.Scene.Field.filter_event/3","type":"function"},{"doc":"Updatet den Graph wenn ein neuer Zustand vom Zellautomaten berechnet wurde.Wartet auf eine Message vom Zellautomaten. Diese enthält einenen aktuellen Graphen. Der aktuelle Graph wird mit build_rect erstellt. Dieser wird anschießend angezeigt. übergibt den State den neuen Zustand des Zellautomaten.","ref":"GameOfLife.Scene.Field.html#handle_info/2","title":"GameOfLife.Scene.Field.handle_info/2","type":"function"},{"doc":"Ändert den Zustand der Zelle auf die geclickt wurde.Berrechnet ob der click auf dem Zellgitter getätigt wurde und berechnet die Zelle auf der die Interaktion statt fand.","ref":"GameOfLife.Scene.Field.html#handle_input/3","title":"GameOfLife.Scene.Field.handle_input/3","type":"function"},{"doc":"Initialisierung der OberflächeLäst das Gitter anhand der Dimensionen aus Agent :xy aufbauen.","ref":"GameOfLife.Scene.Field.html#init/2","title":"GameOfLife.Scene.Field.init/2","type":"function"},{"doc":"Scene wird als erstes aufgerufen. In ihr werden die Dimension des Zellautomaten eingegeben.Wichtig: Zellen nur in Dimensionen bis maximal 20x20 eingeben. In der aktuellen Version eine Limitation des Frameworks","ref":"GameOfLife.Scene.Home.html","title":"GameOfLife.Scene.Home","type":"module"},{"doc":"Reagiert auf Benutzereingaben{:click, :start} Startet und übergibt den Zellautomaten die Dimensionen. Ruft das Hauptfenster auf.{:value_changed, :reihe, value} Neuer Wert für Reihe im State aktualisiert.{:value_changed, :spalte, value} Neuer Wert für Zeile im State akualisiert.","ref":"GameOfLife.Scene.Home.html#filter_event/3","title":"GameOfLife.Scene.Home.filter_event/3","type":"function"},{"doc":"Callback implementation for Scenic.Scene.init/2.","ref":"GameOfLife.Scene.Home.html#init/2","title":"GameOfLife.Scene.Home.init/2","type":"function"},{"doc":"Enthält alle Zellen die im nächsten Schritt berechnet werden müssen.Wird als zwischen speicher genutzt.","ref":"Todo.html","title":"Todo","type":"module"},{"doc":"Nimmt eine Neue zu bearbeitende Zelle in die Liste auf.","ref":"Todo.html#add_to_list/1","title":"Todo.add_to_list/1","type":"function"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Todo.html#child_spec/1","title":"Todo.child_spec/1","type":"function"},{"doc":"Löscht alle Zellen aus der Liste.","ref":"Todo.html#dell_list/0","title":"Todo.dell_list/0","type":"function"},{"doc":"Gibt eine Liste an Zellen zurück die entsprechend bearbeitet werden sollen.","ref":"Todo.html#get_list/0","title":"Todo.get_list/0","type":"function"},{"doc":"Registriert den Prozess auf den passenden Namen.","ref":"Todo.html#start_link/1","title":"Todo.start_link/1","type":"function"},{"doc":"Enthält weitere Parameter für den Zellautomaten.Prameter sind z.b. X Dimension :x Y Dimension :y Automatisches weiterlaufen :toggel Angabe über torisch oder nicht :torisch","ref":"XY.html","title":"XY","type":"module"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"XY.html#child_spec/1","title":"XY.child_spec/1","type":"function"},{"doc":"Bekommt den Wert an der Stelle des Parameter zurück.","ref":"XY.html#get/1","title":"XY.get/1","type":"function"},{"doc":"Gibt alle Parameter als map zurück.","ref":"XY.html#get_all/0","title":"XY.get_all/0","type":"function"},{"doc":"Setzt einen einen paramert auf das mitgelieferte value","ref":"XY.html#set/2","title":"XY.set/2","type":"function"},{"doc":"Registriert den Prozess auf den passenden Namen.","ref":"XY.html#start_link/1","title":"XY.start_link/1","type":"function"},{"doc":"Logic des Zellautomaten.Die nötigen Paarameter werden in Agents gespeichert. Der Zelleautomat wird als Genserver Implementiert und von einem Supervisor überwacht. Er kann abstürtzen ohne das ein Datenverlust statt findet.","ref":"Zellautomat.html","title":"Zellautomat","type":"module"},{"doc":"Enscheidet über den Zustand der ZelleÜberprüft ob die Zelle den Wert 0 oder 1 bekommt, anhand des eigenen Wertes und der Summe der Nachbarn. Übergibt nur Zellen mit Wert 1 dem :new_map Agent","ref":"Zellautomat.html#alive_in_new_map/1","title":"Zellautomat.alive_in_new_map/1","type":"function"},{"doc":"Summe der NachtbarnBerechnet die Summe der Umligenden Zellen und gibt diese zurück.","ref":"Zellautomat.html#around_wert/7","title":"Zellautomat.around_wert/7","type":"function"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Zellautomat.html#child_spec/1","title":"Zellautomat.child_spec/1","type":"function"},{"doc":"Alle n Sekunden wird ein neuer Zustand der Zellautomaten berechnet.Durch den Parameter toggle kann diese Funktion an oder ausgeschaltet werden. Gibt den neuen Zustand zurück.","ref":"Zellautomat.html#handle_info/2","title":"Zellautomat.handle_info/2","type":"function"},{"doc":"Initialisierung des Automaten.Starten des Zellautomaten Als Genserver. Optionale Parameter sind noch nicht vorgesehen.","ref":"Zellautomat.html#start_link/1","title":"Zellautomat.start_link/1","type":"function"},{"doc":"Lässt den nächsten Zustand des Zellautomaten berechnen.Lässten nächten Zustand berechnen und gibt die neuen Werte an die Agents weiter. Nur Zellen die den Wert 1 haben oder Nachtbar einer Zelle mit dem Wert 1 sind, werden berechnet.","ref":"Zellautomat.html#tick/0","title":"Zellautomat.tick/0","type":"function"},{"doc":"Ermittelt Nachtbarn und die angegebene Zelle.Übergibt alle Nachtbarn und die angegebene Zelle, dem :todo Agent. Es sei den, sie befinden sich auserhalb des Zellautomaten.","ref":"Zellautomat.html#todo_zellen_around/1","title":"Zellautomat.todo_zellen_around/1","type":"function"},{"doc":"Setzt eine Zelle auseherhalb der Dimension in den Torischen Bereich","ref":"Zellautomat.html#torus_func/2","title":"Zellautomat.torus_func/2","type":"function"},{"doc":"Gibt die Koordinaten im Zellautomaten wiederParameterx, y: Koordinaten im Zellautomaten","ref":"Zelle.html","title":"Zelle","type":"module"},{"doc":"","ref":"Zelle.html#t:t/0","title":"Zelle.t/0","type":"type"},{"doc":"Es Speicher für den Zellautomaten.Enthält zwei Maps einen für den Aktuellen Zustand und einen für den neuen Zustand des Automaten.","ref":"Zustand.html","title":"Zustand","type":"module"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Zustand.html#child_spec/1","title":"Zustand.child_spec/1","type":"function"},{"doc":"Der neu berechnete Zustand des Zellautomaten wird als aktueller Zustand festgelegt.Die Map für den Alten Zustand wird gelöscht.","ref":"Zustand.html#end_tick/0","title":"Zustand.end_tick/0","type":"function"},{"doc":"Gibt den Wert der Aktuellen Zelle zurück.Wenn die Zelle sich auserhalb der Dimensionen befindet wird Sie auch als 0 betrachtet.","ref":"Zustand.html#get_akt_cell_wert/1","title":"Zustand.get_akt_cell_wert/1","type":"function"},{"doc":"Der aktuelle Zustand wird als Map übergeben.","ref":"Zustand.html#get_akt_map/0","title":"Zustand.get_akt_map/0","type":"function"},{"doc":"Setzt eine übergebende Zelle mit dem Wert 1 in die Map für den neuen Zustand","ref":"Zustand.html#set_new_cell/1","title":"Zustand.set_new_cell/1","type":"function"},{"doc":"Startet die Agents für den Aktuellen und zu berechnenden Zustand.","ref":"Zustand.html#start_link/1","title":"Zustand.start_link/1","type":"function"},{"doc":"Verändert die übergebenden Zellen im Aktuellen Zustand des Automaten.Die übergebenden Zellen werden im Automaten von null auf eins oder umgekert gesetzt.","ref":"Zustand.html#toggel_cell/1","title":"Zustand.toggel_cell/1","type":"function"},{"doc":"GameOfLifeDies ist eine kleine Implementation von Conways Spiel des Lebens. Das Programm ist in Elixir geschrieben und nutzt das Scenic von Boyd Multerer als Grafik Framework.","ref":"gameoflife.html","title":"GameOfLife","type":"extras"},{"doc":"InstallationBedienungAnforderungen und ÜberlegungenKritik und ÄnderungenChangelog","ref":"gameoflife.html#%C3%BCbersicht","title":"GameOfLife - Übersicht","type":"extras"},{"doc":"InstallationUm dieses Programm kompilieren und ausführen zu können, sind ein paar Besonderheiten zu beachten.-Betriebssystem: Aufgrund des Frameworks wird entweder eine Linux oder MacOS Distribution vorausgesetzt. Alternativ ist es möglich das Programm in Windows und WSL zu starten.-Erlang und Elixir: Für das Ausführen des Programms ist eine Installation der Erlang- VM und von Elixir nötig.-Bibliotheken: Scenic setzt GLFW und GLEW Bibliotheken voraus. Installationsanleitungen finden Sie hier.","ref":"installation.html","title":"Installation","type":"extras"},{"doc":"sudo apt-get update sudo apt-get install pkgconf libglfw3 libglfw3-dev libglew2.1 libglew-dev","ref":"installation.html#f%C3%BCr-ubuntu-20","title":"Installation - Für Ubuntu 20","type":"extras"},{"doc":"Zum Nutzen von Scenic unter WSL folgen Sie dieser Anleitung.-Vor dem Kompilieren: Nach dem clonen des Git-Repositorys werden mit dem Befehle mix do deps.getdie restlichen Abhängigkeiten heruntergeladen.Mit mix scenic.runwird das Programm gestartet.","ref":"installation.html#f%C3%BCr-wsl-unter-windows-10","title":"Installation - Für WSL unter Windows 10","type":"extras"},{"doc":"BedienungDas Besteht aus zwei verschiedenen Ansichten.","ref":"bedienung.html","title":"Bedienung","type":"extras"},{"doc":"In der ersten Ansicht wird die Dimension ausgewählt, die nachher der Zellautomat haben soll. Dazu wird in den jeweiligen Textfeldern die entsprechende Zahl eingetragen.","ref":"bedienung.html#auswahl","title":"Bedienung - Auswahl","type":"extras"},{"doc":"In der zweiten Ansicht ist jetzt das Feld des Zellautomaten zu sehen. Die einzelnen Felder können durch anklicken ihren Status ändern.Unten links ist der Button next zu sehen. Durch Auslösen des Buttons wird der nächste Zustand des Buttons berechnet und angezeigt.Unten Rechts ist der Button run zu sehen. Dieser lässt den Zellautomaten in Intervallen jede Sekunde neu berechnen. Durch einen weiteren click auf den Button wird der Automat wieder angehalten.","ref":"bedienung.html#das-feld","title":"Bedienung - Das Feld","type":"extras"},{"doc":"Anforderungen und Überlegungen","ref":"anforderungen.html","title":"Anforderungen und Überlegungen","type":"extras"},{"doc":"Für mich gab es zu diesem Projekt ein paar Anforderungen, die ich mir im Vorhinein aufgeschrieben hatte.1.) Das Programm soll eine grafische Nutzeroberfläche haben, in der der Zellautomat dargestellt wird. 2.) Der Zellautomat muss mit verschiedenen Dimensionen initialisiert werden können.3.) Ein Feld im Zellautomaten kann durch anklicken ihren Zustand wechseln.4.) Der Nutzer soll die Möglichkeit haben durch eine Eingabe den nächsten Zustand berechnen zu lassen.5.) Der Nutzer soll die Möglichkeit haben durch eine Eingabe die nächsten Zustände in einem Intervall berechnen zu lassen.","ref":"anforderungen.html#anforderungen","title":"Anforderungen und Überlegungen - Anforderungen","type":"extras"},{"doc":"Die Wahl der Programmiersprache ist in diesem Fall aus persönlichen Gründen gefallen. Ich habe vor kurzem angefangen mit Elixir zu beschäftigen und habe gedacht das dies eine weitere gute Übung für mich in dieser Sprache sein kann. Allerdings habe ich zuvor nicht mit Oberflächen in dieser Sprache gearbeitet. Die Wahl des Grafik Frameworks fiel auf Scenic. Dies schien mir als die beste Lösung um es in der kurzen Zeit so weit zu verstehen, dass ich das Projekt damit umsetzten könnte. Allerdings bin ich bei der Ausarbeitung auf Limitationen gestoßen.","ref":"anforderungen.html#auswahl-der-programmiersprache","title":"Anforderungen und Überlegungen - Auswahl der Programmiersprache","type":"extras"},{"doc":"Das Programm ist in drei Schichten aufgebaut. Frontend, Logik und Datenhaltung. Jeder dieser Schichten ist in einzelnen Prozessen ausgefürt. Die Prozesse werden vom Supervisor überwacht und neu gestartet sobalt einer aufgrund eines Fehlers abstürtzen sollte.Das Programm besteht im weitesten Sinne aus Frontend und Backend. Das Frontend hier die Nutzeroberfläche reagiert auf Nutzereingaben und schick diese als Elixir Massage an die Logik. Der Zellautomat ist in diesem Fall die Logik verarbeitet Massages und berechnet den neuen Zustand. Die nötigen Informationen und der Zustand des Zellautomaten werden in der Datenhaltung gespeichert. Das Frontend hat eine dedizierte callback Methode, die aufgerufen wird wenn der Zellautomat einen neuen Zustand errechnet hat. Dieser aktualisiert die Oberfläche auf der der Zustand des Zellautomaten angezeigt wird.Besonderheiten der NutzeroberflächeDas Feld des Zellautomaten in der Nutzeroberfläche ist über Primitive Rechtecke realisiert. Nach dem clicken in das Feld wird ein Struct der Zelle angefertigt, auf die geclickt wurde. Dieses wird auch im Server zur Adressierung genutzt. Besonderheiten der LogikDie Logik ist ein separater Prozess. Die Datenspeicherung übernehmen weitere Prozesse. Die sogenannten Agents. Da die Elixir Standard Bibliothek keine Arrays anbietet, habe ich beschlossen die Werte als Key Value Paare zu speichern, wobei der Key das Struct vom Typ Zelle ist. Um Speicher zu sparen werden nach Möglichkeit nur Zellen mit dem Value 1 (also lebende) gespeichert. Um Rechenleistung zu sparen werden für den nächsten Zustand nur die lebenden Zellen und deren Nachbarn berechnet.","ref":"anforderungen.html#struktur-des-programms","title":"Anforderungen und Überlegungen - Struktur des Programms","type":"extras"},{"doc":"Kritik und Änderungen","ref":"kritikund%C3%A4nderungen.html","title":"Kritik und Änderungen","type":"extras"},{"doc":"Das Programm ist in drei großen Punkten limitiertDimension: Durch die Nutzung von Buttons im Feld des Zellautomaten, ist das Programm in der Dimension beschränkt. Ab einer gewissen Zahl an Button stürzt das Grafik Framework ab.Note: in v0.3.0 werde Primitive Rechtecke statt Buttons genutzt so ist es jetzt möglich eine größere Dimension zu nutzen.Note: in v0.3.1 wurde es noch effizenter umgesetzt.Aktualisierung: Es ist mir kein Weg bekannt gewesen eine Callback Methode in der Nutzeroberfläche zu implementieren. Dadurch kann der Server des Zellautomaten keine Aktualisierung der Nutzeroberfläche anstoßen.Note: in v0.2.5 kann der Zellautomat auch die Nutzeroberfläche aktualisieren.Anpassbarkeit Das Programm ist nur auf eine Fenstergröße ausgerichtet. Diese kann nicht verändert werden.","ref":"kritikund%C3%A4nderungen.html#limitationen","title":"Kritik und Änderungen - Limitationen","type":"extras"},{"doc":"Ein Programm zu erstellen mit einem Framwork, das man erst während des versteht, birgt einige Risiken. Vor allem, wenn Limitationen erst nach und nach bekannt werden.","ref":"kritikund%C3%A4nderungen.html#kritik","title":"Kritik und Änderungen - Kritik","type":"extras"},{"doc":"Für eine Zukünftige weitere Entwicklung des Programms währen folgende Dinge möglich.Button ersetzen: Um mehr Zellen in der Benutzeroberflächen anzeigen zu können. Müssen die Button durch z.B. Rechtecke (Rect) ersetzt werden. Diese können in höheren Stückzahlen erscheinen. (In v0.3.0 umgesetzt)Aktualisierung: Eine Möglichkeit finden die einen Oberflächenaktualisierung in Intervallen ermöglicht. (In v0.2.5 behoben)Testerweiterung: Die Tests in der aktuellen Version decken nur einen kleinen Teil des Programms ab. Diese sollten in Zukunft ausgebaut werden.Fensteränderung: Zukünftig sollte man in der ersten Ansicht die Möglichkeit haben die Größe des Fensters einzustellen oder zumindest einen Skalierungsfaktor zu nutzen. Dynamisches ändern von Parametern: Es sollen zur Laufzeit die Dimesionen wie auch Parameter wie Aktualisierungsrate und Torisch verändert werden können.Platzieren von Gleitern: Es soll ein Dropdown Menü geben in dem man aus verschiedenen Gleitern auswählen kann. Diese können mit einem click auf dem Feld platziert werden. Ändern der Weltregeln: Es soll möglich sein zur Laufzeit die Regeln Welt zu ändern.","ref":"kritikund%C3%A4nderungen.html#%C3%A4nderungen","title":"Kritik und Änderungen - Änderungen","type":"extras"},{"doc":"Changelog.0.3.5 Datenhaltung von Logik getrennt Fehler die zum Absturz der Logik führen gehen nicht mehr mit Verlust der Daten einher.0.3.1 Anzeigeleistung im Gui Thread verbessert. Dimensionen von 200 x 200 sind jetzt ohne Probleme möglich.0.3.0 Dimensionsbeschränkung des Pogrammes aufgehoben.0.2.5 Automatische aktualisierung möglich.0.2.0 Erste lauffähige Applikation.","ref":"changelog.html","title":"Changelog.","type":"extras"}]