searchNodes=[{"doc":"Der Einsprungspunkt des Prgramms","ref":"GameOfLife.html","title":"GameOfLife","type":"module"},{"doc":"","ref":"GameOfLife.html#start/2","title":"GameOfLife.start/2","type":"function"},{"doc":"Ist die eingentliche Ansicht des Zellautomaten.Besteht aus einem Spielfeld aus Buttons, die jeweils eine Zelle representieren. Durch den Button &quot;next&quot; kann der nächte Zustand des Spielfeldes berechnet werden. Durch &quot;run&quot; wird der der Zelleautomat angegewiesen in Intervallen seinen Zustand neu zu berechnen.","ref":"GameOfLife.Scene.Field.html","title":"GameOfLife.Scene.Field","type":"module"},{"doc":"Baut das Zellgitter mit den jeweiligen state des Zellautomaten auf.Funktion erstellt Rechtecke in passenden Größen und Positionen gemäß des State des Zellautomaten.","ref":"GameOfLife.Scene.Field.html#build_rect/6","title":"GameOfLife.Scene.Field.build_rect/6","type":"function"},{"doc":"Verarbeitet die Eingabe eines Buttons.{:click, :next_step} Lässt den Automaten den neuen Zustand berechnen.{:click, :intervall} Gibt den Zellautomaten dass Signal automatisch weiter zu laufen oder aufzuhören. Updatete den Button entsprechend.","ref":"GameOfLife.Scene.Field.html#filter_event/3","title":"GameOfLife.Scene.Field.filter_event/3","type":"function"},{"doc":"Updatet den Graph wenn ein neuer Zustand vom Zellautomaten berechnet wurde.Wartet auf eine Message vom Zellautomaten. Diese enthält einenen aktuellen Graphen. Der aktuelle Graph wird mit build_rect erstellt. Dieser wird anschießend angezeigt. übergibt den State die neuen dimensionen und den Zustand des Zellautomaten.","ref":"GameOfLife.Scene.Field.html#handle_info/2","title":"GameOfLife.Scene.Field.handle_info/2","type":"function"},{"doc":"Ändert den Zustand der Zelle auf die geclickt wurde.Berrechnet ob der click auf dem Zellgitter getätigt wurde und berechnet die Zelle auf der die Interaktion statt fand.","ref":"GameOfLife.Scene.Field.html#handle_input/3","title":"GameOfLife.Scene.Field.handle_input/3","type":"function"},{"doc":"Initialisierung der OberflächeLäst das Gitter anhand der Dimensionen aus Agent :xy aufbauen.","ref":"GameOfLife.Scene.Field.html#init/2","title":"GameOfLife.Scene.Field.init/2","type":"function"},{"doc":"Scene wird als erstes aufgerufen. In ihr werden die Dimension des Zellautomaten eingegeben.Wichtig: Zellen nur in Dimensionen bis maximal 20x20 eingeben. In der aktuellen Version eine Limitation des Frameworks","ref":"GameOfLife.Scene.Home.html","title":"GameOfLife.Scene.Home","type":"module"},{"doc":"Reagiert auf Benutzereingaben{:click, :start} Startet und übergibt den Zellautomaten die Dimensionen. Ruft das Hauptfenster auf.{:value_changed, :reihe, value} Neuer Wert für Reihe im State aktualisiert.{:value_changed, :spalte, value} Neuer Wert für Zeile im State akualisiert.","ref":"GameOfLife.Scene.Home.html#filter_event/3","title":"GameOfLife.Scene.Home.filter_event/3","type":"function"},{"doc":"Callback implementation for Scenic.Scene.init/2.","ref":"GameOfLife.Scene.Home.html#init/2","title":"GameOfLife.Scene.Home.init/2","type":"function"},{"doc":"Logic des Zellautomaten. Die nötigen Paarameter werden in Agents gespeichert.Agents:xy: hier werden die Dimensionen des Zellautomaten gespeichert es wird auch noch gespeichert ob der Automat von selber laufen soll oder nichtakt_map: Die Werte der zellen werden als 1 und 0 in einer map mit dem Zellenstruct als id gespeichert um Platz zu sparen werden nach möglichkeit nur zellen mit 1 gespeichertnew_map: dient als Zwischenspicher bei der Berechnung des neuen Zellautomatentodo: enthält Zellen die zum nächsten Schritt neu berechnet werden müssen","ref":"Zellautomat.html","title":"Zellautomat","type":"module"},{"doc":"Enscheidet über den Zustand der ZelleÜberprüft ob die Zelle den Wert 0 oder 1 bekommt, anhand des eigenen Wertes und der Summe der Nachbarn. Übergibt nur Zellen mit Wert 1 dem :new_map Agent","ref":"Zellautomat.html#alive_in_new_map/1","title":"Zellautomat.alive_in_new_map/1","type":"function"},{"doc":"Summe der NachtbarnBerechnet die Summe der Umligenden Zellen und gibt diese zurück.","ref":"Zellautomat.html#around_wert/6","title":"Zellautomat.around_wert/6","type":"function"},{"doc":"HauptschleifeEs werde drei Signale verarbeitet die neuen Werte werden über {:new_map, data :: map()} zurück gegeben.toggel_cell: Es kann geziehlt eine Zelle an oder aus geschaltet werden, abhängig von ihrem aktuellen Zustand.new_tick: Der nächste Zustand des Automaten wird berechnet.automatic_tick: Alle n Sekunden wird ein neuer Zustand der Zellautomaten berechnet. Durch den Parameter toggle kann diese Funktion an oder ausgeschaltet werden. Gibt den neuen Zustand zurück.","ref":"Zellautomat.html#automat/0","title":"Zellautomat.automat/0","type":"function"},{"doc":"Initialisierung des Automaten.Starten der Agenten und setzen der Dimensionen für den Zellautomaten.","ref":"Zellautomat.html#init/0","title":"Zellautomat.init/0","type":"function"},{"doc":"Lässt den nächsten Zustand des Zellautomaten berechnen.Lässten nächten Zustand berechnen und gibt die neuen Werte an die Agents weiter. Nur Zellen die den Wert 1 haben oder Nachtbar einer Zelle mit dem Wert 1 sind, werden berechnet.","ref":"Zellautomat.html#tick/0","title":"Zellautomat.tick/0","type":"function"},{"doc":"Ermittelt Nachtbarn und die angegebene Zelle.Übergibt alle Nachtbarn und die angegebene Zelle, dem :todo Agent. Es sei den, sie befinden sich auserhalb des Zellautomaten.","ref":"Zellautomat.html#todo_zellen_around/1","title":"Zellautomat.todo_zellen_around/1","type":"function"},{"doc":"Gibt die Koordinaten im Zellautomaten wiederParameterx, y: Koordinaten im Zellautomaten","ref":"Zelle.html","title":"Zelle","type":"module"},{"doc":"","ref":"Zelle.html#t:t/0","title":"Zelle.t/0","type":"type"},{"doc":"GameOfLifeDies ist eine kleine Implementation von Conways Spiel des Lebens. Das Programm ist in Elixir geschrieben und nutzt das Scenic von Boyd Multerer als Grafik Framework.","ref":"gameoflife.html","title":"GameOfLife","type":"extras"},{"doc":"InstallationBedienungAnforderungen und ÜberlegungenKritik und Änderungen","ref":"gameoflife.html#%C3%BCbersicht","title":"GameOfLife - Übersicht","type":"extras"},{"doc":"InstallationUm dieses Programm kompilieren und ausführen zu können, sind ein paar Besonderheiten zu beachten.-Betriebssystem: Aufgrund des Frameworks wird entweder eine Linux oder MacOS Distribution vorausgesetzt. Alternativ ist es möglich das Programm in Windows und WSL zu starten.-Erlang und Elixir: Für das Ausführen des Programms ist eine Installation der Erlang- VM und von Elixir nötig.-Bibliotheken: Scenic setzt GLFW und GLEW Bibliotheken voraus. Installationsanleitungen finden Sie hier.","ref":"installation.html","title":"Installation","type":"extras"},{"doc":"sudo apt-get update sudo apt-get install pkgconf libglfw3 libglfw3-dev libglew2.1 libglew-dev","ref":"installation.html#f%C3%BCr-ubuntu-20","title":"Installation - Für Ubuntu 20","type":"extras"},{"doc":"Zum Nutzen von Scenic unter WSL folgen Sie dieser Anleitung.-Vor dem Kompilieren: Nach dem clonen des Git-Repositorys werden mit dem Befehle mix do deps.getdie restlichen Abhängigkeiten heruntergeladen.Mit mix scenic.runwird das Programm gestartet.","ref":"installation.html#f%C3%BCr-wsl-unter-windows-10","title":"Installation - Für WSL unter Windows 10","type":"extras"},{"doc":"BedienungDas Besteht aus zwei verschiedenen Ansichten.","ref":"bedienung.html","title":"Bedienung","type":"extras"},{"doc":"In der ersten Ansicht wird die Dimension ausgewählt, die nachher der Zellautomat haben soll. Dazu wird in den jeweiligen Textfeldern die entsprechende Zahl eingetragen.","ref":"bedienung.html#auswahl","title":"Bedienung - Auswahl","type":"extras"},{"doc":"In der zweiten Ansicht ist jetzt das Feld des Zellautomaten zu sehen. Die einzelnen Felder können durch anklicken ihren Status ändern.Unten links ist der Button next zu sehen. Durch Auslösen des Buttons wird der nächste Zustand des Buttons berechnet und angezeigt.Unten Rechts ist der Button run zu sehen. Dieser lässt den Zellautomaten in Intervallen jede Sekunde neu berechnen. Durch einen weiteren click auf den Button wird der Automat wieder angehalten.","ref":"bedienung.html#das-feld","title":"Bedienung - Das Feld","type":"extras"},{"doc":"Anforderungen und Überlegungen","ref":"anforderungen.html","title":"Anforderungen und Überlegungen","type":"extras"},{"doc":"Für mich gab es zu diesem Projekt ein paar Anforderungen, die ich mir im Vorhinein aufgeschrieben hatte.1.) Das Programm soll eine grafische Nutzeroberfläche haben, in der der Zellautomat dargestellt wird. 2.) Der Zellautomat muss mit verschiedenen Dimensionen initialisiert werden können.3.) Ein Feld im Zellautomaten kann durch anklicken ihren Zustand wechseln.4.) Der Nutzer soll die Möglichkeit haben durch eine Eingabe den nächsten Zustand berechnen zu lassen.5.) Der Nutzer soll die Möglichkeit haben durch eine Eingabe die nächsten Zustände in einem Intervall berechnen zu lassen.","ref":"anforderungen.html#anforderungen","title":"Anforderungen und Überlegungen - Anforderungen","type":"extras"},{"doc":"Die Wahl der Programmiersprache ist in diesem Fall aus persönlichen Gründen gefallen. Ich habe vor kurzem angefangen mit Elixir zu beschäftigen und habe gedacht das dies eine weitere gute Übung für mich in dieser Sprache sein kann. Allerdings habe ich zuvor nicht mit Oberflächen in dieser Sprache gearbeitet. Die Wahl des Grafik Frameworks fiel auf Scenic. Dies schien mir als die beste Lösung um es in der kurzen Zeit so weit zu verstehen, dass ich das Projekt damit umsetzten könnte. Allerdings bin ich bei der Ausarbeitung auf Limitationen gestoßen.","ref":"anforderungen.html#auswahl-der-programmiersprache","title":"Anforderungen und Überlegungen - Auswahl der Programmiersprache","type":"extras"},{"doc":"Das Programm besteht im weitesten Sinne aus Frontend und Backend. Das Frontend hier die Nutzeroberfläche reagiert auf Nutzereingaben und schick diese als Elixir Massage an den Server. Der Zellautomat ist in diesem Fall das Backend es verarbeitet Massages und berchnet den neuen Zustand. Das Frontend hat eine dedizierte callback Methode, die aufgerufen wird wenn der Zellautomat einen neuen Zustand errechnet hat.Besonderheiten der NutzeroberflächeDas Feld des Zellautomaten in der Nutzeroberfläche ist über Primitive Rechtecke realisiert. Nach dem clicken in das Feld wird ein Struct der Zelle angefertigt, auf die geclickt wurde. Dieses wird auch im Server zur Adressierung genutzt. Besonderheiten des ServersDer Server ist ein separater Prozess. Enthält nur die Logik. Die Datenspeicherung übernehmen weitere Prozesse. Die sogenannten Agents. Da die Elixir Standard Bibliothek keine Arrays anbietet, habe ich beschlossen die Werte als Key Value Paare zu speichern, wobei der Key das Struct vom Typ Zelle ist. Um Speicher zu sparen werden nach Möglichkeit nur Zellen mit dem Value 1 (also lebende) gespeichert. Um Rechenleistung zu sparen werden für den nächsten Zustand nur die lebenden Zellen und deren Nachbarn berechnet.","ref":"anforderungen.html#struktur-des-programms","title":"Anforderungen und Überlegungen - Struktur des Programms","type":"extras"},{"doc":"Kritik und Änderungen","ref":"kritikund%C3%A4nderungen.html","title":"Kritik und Änderungen","type":"extras"},{"doc":"Das Programm ist in drei großen Punkten limitiertDimension: Durch die Nutzung von Buttons im Feld des Zellautomaten, ist das Programm in der Dimension beschränkt. Ab einer gewissen Zahl an Button stürzt das Grafik Framework ab.Note: in v0.3.0 werde Primitive Rechtecke statt Buttons genutzt so ist es jetzt möglich eine größere Dimension zu nutzen.Aktualisierung: Es ist mir kein Weg bekannt gewesen eine Callback Methode in der Nutzeroberfläche zu implementieren. Dadurch kann der Server des Zellautomaten keine Aktualisierung der Nutzeroberfläche anstoßen.Note: in v0.2.5 kann der Zellautomat auch die Nutzeroberfläche aktualisieren.Anpassbarkeit Das Programm ist nur auf eine Fenstergröße ausgerichtet. Diese kann nicht verändert werden.","ref":"kritikund%C3%A4nderungen.html#limitationen","title":"Kritik und Änderungen - Limitationen","type":"extras"},{"doc":"Ein Programm zu erstellen mit einem Framwork, das man erst während des versteht, birgt einige Risiken. Vor allem, wenn Limitationen erst nach und nach bekannt werden.","ref":"kritikund%C3%A4nderungen.html#kritik","title":"Kritik und Änderungen - Kritik","type":"extras"},{"doc":"Für eine Zukünftige weitere Entwicklung des Programms währen folgende Dinge möglich.Button ersetzen: Um mehr Zellen in der Benutzeroberflächen anzeigen zu können. Müssen die Button durch z.B. Rechtecke (Rect) ersetzt werden. Diese können in höheren Stückzahlen erscheinen. (In v0.3.0 umgesetzt)Aktualisierung: Eine Möglichkeit finden die einen Oberflächenaktualisierung in Intervallen ermöglicht. (In v0.2.5 behoben)Testerweiterung: Die Tests in der aktuellen Version decken nur einen kleinen Teil des Programms ab. Diese sollten in Zukunft ausgebaut werden.Fensteränderung: Zukünftig sollte man in der ersten Ansicht die Möglichkeit haben die Größe des Fensters einzustellen oder zumindest einen Skalierungsfaktor zu nutzen.","ref":"kritikund%C3%A4nderungen.html#%C3%A4nderungen","title":"Kritik und Änderungen - Änderungen","type":"extras"}]